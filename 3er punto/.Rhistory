# install.packages("readxl")
library(readxl)
datos <- read_excel("Metro.xlsx")
read_excel
View(datos)
View(datos)
x <- c(datos$`Tiempo V1` , datos$`Tiempo V2` , datos$`Tiempo V3`)
y < c(datos$`Velocidad V1` , datos$`Velocidad V2` , datos$`Velocidad V3`)
x <- c(datos$`Tiempo V1` , datos$`Tiempo V2` , datos$`Tiempo V3`)
y < c(datos$`Velocidad V1` , datos$`Velocidad V2` , datos$`Velocidad V3`)
y < c(datos$`Velocidad V1` , datos$`Velocidad V2` , datos$`Velocidad V3`)
x <- c(datos$`Tiempo V1` , datos$`Tiempo V2` , datos$`Tiempo V3`)
y <- c(datos$`Velocidad V1` , datos$`Velocidad V2` , datos$`Velocidad V3`)
plot(x , y)
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ I(x^teta), start = list(teta = 1))
# summary(m1)
# teta <- coefficients(m1)
#
#
# points(xx,(xx^teta),type="l",col="red")
summary(m1)
teta <- coefficients(m1)
teta <- coefficients(m1)
plot(x,y)
points(x,(x^teta),type="l",col="red")
points(x,(x^2),type="l",col="red")
plot(x,y)
points(x,(x^3),type="l",col="red")
plot(x,y)
points(x,(x^1),type="l",col="red")
plot(x,y)
points(x,(x^2),type="l",col="red")
plot(x,y)
points(x,(x^2.5),type="l",col="red")
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ x^p+c, start = list(teta = 1))
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ x^p+c, start = list(p = 1,c=1))
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ x^p+c, start = list(p = 1,c=2))
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ x^p+c, start = list(p = 1,c=4))
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ x^p + c, start = list(p = 1, c = 4))
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ x^p + c, start = list(p = 2, c = 4))
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ x^p + c)
m1 <- nls(y ~ (x^p + c))
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ (x^p + c),start = list(p = 1, c = 2))
x <- c(datos$`Tiempo V1` , datos$`Tiempo V2` , datos$`Tiempo V3`)
y <- c(datos$`Velocidad V1` , datos$`Velocidad V2` , datos$`Velocidad V3`)
datos <- data.frame(x=x,y=y)
View(datos)
View(datos)
estimar_valores_iniciales <- function(datos=datos) {
# Gráfico de dispersión de y vs. x
plot(datos$x, datos$y, main = "Gráfico de dispersión", xlab = "x", ylab = "y")
# Utiliza la función locator() para seleccionar puntos en el gráfico
puntos <- locator(n = 2, type = "p", col = "red")
# Extrae las coordenadas de los puntos seleccionados
x_valores_iniciales <- puntos$x
y_valores_iniciales <- puntos$y
# Calcula los valores iniciales para p y c
p_inicial <- log(y_valores_iniciales[2] - y_valores_iniciales[1]) / log(x_valores_iniciales[2] - x_valores_iniciales[1])
c_inicial <- y_valores_iniciales[1] - x_valores_iniciales[1]^p_inicial
# Devuelve los valores iniciales estimados
return(list(p_inicial = p_inicial, c_inicial = c_inicial))
}
# Uso de la función para estimar valores iniciales
valores_iniciales_estimados <- estimar_valores_iniciales(datos)
print(valores_iniciales_estimados)
View(valores_iniciales_estimados)
install.packages("minpack.lm")
# Cargar la biblioteca minpack.lm
library(minpack.lm)
# Función de modelo
modelo <- function(x, p, c) {
return(x^p + c)
}
# Estimar valores iniciales utilizando nlsLM
ajuste_inicial <- nlsLM(y ~ modelo(x, p, c), start = list(p = 1, c = 1))
# Obtener los valores iniciales estimados
valores_iniciales_estimados <- coef(ajuste_inicial)
print(valores_iniciales_estimados)
# Ajustar el modelo final con los valores iniciales estimados
ajuste_final <- nlsLM(y ~ modelo(x, p, c), start = valores_iniciales_estimados)
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ (x^p + c),start = list(p = -2.334564, c = 12.074168 ))
# summary(m1)
# teta <- coefficients(m1)
# points(xx,(xx^teta),type="l",col="red")
summary(m1)
teta <- coefficients(m1)
teta
teta[0]
teta[,0]
plot(x,y)
points(x,(x^(-2.334684) + 12.074184 ),type="l",col="red")
# Cargar la biblioteca minpack.lm
library(minpack.lm)
# Función de modelo
modelo <- function(x, p, c) {
return(x^p + c)
}
# Estimar valores iniciales utilizando nlsLM
ajuste_inicial <- nlsLM(y ~ modelo(x, p, c), start = list(p = 2, c = 4))
# Obtener los valores iniciales estimados
valores_iniciales_estimados <- coef(ajuste_inicial)
print(valores_iniciales_estimados)
# Ajustar el modelo final con los valores iniciales estimados
ajuste_final <- nlsLM(y ~ modelo(x, p, c), start = valores_iniciales_estimados)
# Cargar la biblioteca minpack.lm
library(minpack.lm)
# Función de modelo
modelo <- function(x, p, c) {
return(x^p + c)
}
# Estimar valores iniciales utilizando nlsLM
ajuste_inicial <- nlsLM(y ~ modelo(x, p, c), start = list(p = 4, c = 4))
# Obtener los valores iniciales estimados
valores_iniciales_estimados <- coef(ajuste_inicial)
print(valores_iniciales_estimados)
# Ajustar el modelo final con los valores iniciales estimados
ajuste_final <- nlsLM(y ~ modelo(x, p, c), start = valores_iniciales_estimados)
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ (x^p + c),start = list(p = 1, c = 1 ),weights = 1/(y^2))
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ ((x-a)^p + c),start = list(a=0.8,p = -1, c = 9 ))
x
legend(x)
length(x)
length(y)
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ I((x-a)^p + c),start = list(a=0.8,p = -1, c = 9 ))
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ (x-a)^p + c,start = list(a=0.8,p = -1, c = 9 ))
# install.packages("readxl")
library(readxl)
datos <- read_excel("Metro.xlsx")
datos
x <- c(datos$`Tiempo V1` , datos$`Tiempo V2` , datos$`Tiempo V3`)
y <- c(datos$`Velocidad V1` , datos$`Velocidad V2` , datos$`Velocidad V3`)
datos <- data.frame(x=x,y=y)
datos
plot(x , y)
hist(datos)
hist(x,y)
install.packages("minpack.lm")
library(minpack.lm)
modelo <- function(x, p, c) {
return(x^p + c)
}
install.packages("nls2")
ajuste_inicial <- nlsLM(y ~ modelo(x, p, c), start = list(p = , c = 4))
ajuste_inicial <- nlsLM(y ~ modelo(x, p, c), start = list(p =-0.6 , c = 4))
# Obtener los valores iniciales estimados
valores_iniciales_estimados <- coef(ajuste_inicial)
print(valores_iniciales_estimados)
# Ajustar el modelo final con los valores iniciales estimados
ajuste_final <- nlsLM(y ~ modelo(x, p, c), start = valores_iniciales_estimados)
ajuste_final
summary(ajuste_final)
summary(ajuste_final)
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ (x-a)^p + c,start = list(a=0.8,p = -1, c = 9 ))
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ (x-a)^p + c, data= datos, start = list(a=0.8,p = -1, c = 9 ))
View(datos)
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ (x-a)^p + c,start = list(a=0.8,p = -1, c = 9 ))
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ (x-a)^p + c,start = list(a=0.8,p = -1, c = 9 ),  data= datos)
library(nls2)
m1 <- nls2(y ~ (x-a)^p + c,start = list(a=0.8,p = -1, c = 9 ),  data= datos)
??nls
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ (x-a)^p + c,  data= datos, start = list(a=0.8,p = -1, c = 9 ),  algorithm = "plinear")
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ (x-a)^p + c,  data= datos, start = list(a=0.8,p = -1, c = 9 ),  algorithm = "port")
m1
summary(m1)
teta <- coefficients(m1)
teta
plot(x,y)
points(x,(x^(-2.334684) + 12.074184 ),type="l",col="red")
plot(x,y)
points(x,(x^(-2.334684) + 11 ),type="l",col="red")
plot(x,y)
points(x,(x^(-2.334684) + 11 ),type="b",col="red")
plot(x,y)
points(x,(x^(-2.334684) + 12.074184 ),type="b",col="red")
plot(x,y)
points(x,(x^(-2.334684) + 7 ),type="b",col="red")
plot(x,y)
points(x,(x^(-2.334684) + 13 ),type="b",col="red")
plot(x,y)
points(x,(x^(-2.334684) + 11 ),type="b",col="red")
name(datos)
names(datos)
# Ajustar un modelo spline cúbico al Vagón 1
spline_model_vagon<- smooth.spline(datos$x, datos$y, df = 5)  # Puedes ajustar df según la suavidad deseada
spline_model_vagon
# Ajustar un modelo spline cúbico al Vagón 1
spline_model_vagon<- smooth.spline(datos$x, datos$y, df = 5)  # Puedes ajustar df según la suavidad deseada
# Graficar los datos originales y el modelo spline ajustado
plot(datos$x, datos$y, type = "l", col = "blue", xlab = "Tiempo", ylab = "Velocidad")
lines(spline_model_vagon$x, spline_model_vagon$y, col = "red", lwd = 2)
legend("topright", legend = c("Datos Originales", "Spline Ajustado"), col = c("blue", "red"), lty = 1, lwd = 2)
# Ajustar un modelo spline cúbico a los vagones
spline_model_vagon<- smooth.spline(datos$x, datos$y, df = 5)  # Puedes ajustar df según la suavidad deseada
# Graficar los datos originales y el modelo spline ajustado
plot(datos$x, datos$y, type = "l", col = "blue", xlab = "Tiempo", ylab = "Velocidad")
lines(spline_model_vagon$x, spline_model_vagon$y, col = "red", lwd = 2)
legend("topright", legend = c("Datos Originales", "Spline Ajustado"), col = c("blue", "red"), lty = 1, lwd = 2)
# Evaluar el modelo en nuevos valores de tiempo (por ejemplo, para hacer predicciones)
nuevos_tiempos <- c(31, 32, 33)  # Nuevos valores de tiempo
predicciones <- predict(spline_model_vagon, xout = nuevos_tiempos)
print(predicciones$y)
min(datos)
max(datos$x)
min(datos$x)
min(datos$y)
# Ajustar un modelo spline cúbico a los vagones
spline_model_vagon<- smooth.spline(datos$x, datos$y, df = 2)  # Puedes ajustar df según la suavidad deseada
# Graficar los datos originales y el modelo spline ajustado
plot(datos$x, datos$y, type = "l", col = "blue", xlab = "Tiempo", ylab = "Velocidad")
lines(spline_model_vagon$x, spline_model_vagon$y, col = "red", lwd = 2)
legend("topright", legend = c("Datos Originales", "Spline Ajustado"), col = c("blue", "red"), lty = 1, lwd = 2)
# Evaluar el modelo en nuevos valores de tiempo (por ejemplo, para hacer predicciones)
nuevos_tiempos <- c(31, 32, 33)  # Nuevos valores de tiempo
predicciones <- predict(spline_model_vagon, xout = nuevos_tiempos)
print(predicciones$y)
# Ajustar un modelo spline cúbico a los vagones
spline_model_vagon<- smooth.spline(datos$x, datos$y, df = 6)  # Puedes ajustar df según la suavidad deseada
# Graficar los datos originales y el modelo spline ajustado
plot(datos$x, datos$y, type = "l", col = "blue", xlab = "Tiempo", ylab = "Velocidad")
lines(spline_model_vagon$x, spline_model_vagon$y, col = "red", lwd = 2)
legend("topright", legend = c("Datos Originales", "Spline Ajustado"), col = c("blue", "red"), lty = 1, lwd = 2)
# Evaluar el modelo en nuevos valores de tiempo (por ejemplo, para hacer predicciones)
nuevos_tiempos <- c(31, 32, 33)  # Nuevos valores de tiempo
predicciones <- predict(spline_model_vagon, xout = nuevos_tiempos)
print(predicciones$y)
# Ajustar un modelo spline cúbico a los vagones
spline_model_vagon<- smooth.spline(datos$x, datos$y, df = 6)  # Puedes ajustar df según la suavidad deseada
# Graficar los datos originales y el modelo spline ajustado
plot(datos$x, datos$y, type = "b", col = "blue", xlab = "Tiempo de llegada", ylab = "Velocidad de los vagones")
lines(spline_model_vagon$x, spline_model_vagon$y, col = "red", lwd = 2)
legend("topright", legend = c("Datos Originales", "Spline Ajustado"), col = c("blue", "red"), lty = 1, lwd = 2)
# Evaluar el modelo en nuevos valores de tiempo (por ejemplo, para hacer predicciones)
nuevos_tiempos <- c(31, 32, 33)  # Nuevos valores de tiempo
predicciones <- predict(spline_model_vagon, xout = nuevos_tiempos)
print(predicciones$y)
plot(m1)
summary(spline_model_vagon)
spline_model_vagon
# Ajustar un modelo spline cúbico a los vagones
spline_model_vagon<- smooth.spline(datos$x, datos$y, df = 6)  # Puedes ajustar df según la suavidad deseada
# Graficar los datos originales y el modelo spline ajustado
plot(datos$x, datos$y, type = "b", col = "blue", xlab = "Tiempo de llegada", ylab = "Velocidad de los vagones")
lines(spline_model_vagon$x, spline_model_vagon$y, col = "red", lwd = 2)
legend("topright", legend = c("Datos Originales", "Spline Ajustado"), col = c("blue", "red"), lty = 1, lwd = 2)
# Evaluar el modelo en nuevos valores de tiempo (por ejemplo, para hacer predicciones)
nuevos_tiempos <- c(31, 32, 33)  # Nuevos valores de tiempo
predicciones <- predict(spline_model_vagon, xout = nuevos_tiempos)
print(predicciones$y)
