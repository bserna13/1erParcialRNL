# install.packages("readxl")
library(readxl)
datos <- read_excel("Metro.xlsx")
read_excel
View(datos)
View(datos)
x <- c(datos$`Tiempo V1` , datos$`Tiempo V2` , datos$`Tiempo V3`)
y < c(datos$`Velocidad V1` , datos$`Velocidad V2` , datos$`Velocidad V3`)
x <- c(datos$`Tiempo V1` , datos$`Tiempo V2` , datos$`Tiempo V3`)
y < c(datos$`Velocidad V1` , datos$`Velocidad V2` , datos$`Velocidad V3`)
y < c(datos$`Velocidad V1` , datos$`Velocidad V2` , datos$`Velocidad V3`)
x <- c(datos$`Tiempo V1` , datos$`Tiempo V2` , datos$`Tiempo V3`)
y <- c(datos$`Velocidad V1` , datos$`Velocidad V2` , datos$`Velocidad V3`)
plot(x , y)
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ I(x^teta), start = list(teta = 1))
# summary(m1)
# teta <- coefficients(m1)
#
#
# points(xx,(xx^teta),type="l",col="red")
summary(m1)
teta <- coefficients(m1)
teta <- coefficients(m1)
plot(x,y)
points(x,(x^teta),type="l",col="red")
points(x,(x^2),type="l",col="red")
plot(x,y)
points(x,(x^3),type="l",col="red")
plot(x,y)
points(x,(x^1),type="l",col="red")
plot(x,y)
points(x,(x^2),type="l",col="red")
plot(x,y)
points(x,(x^2.5),type="l",col="red")
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ x^p+c, start = list(teta = 1))
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ x^p+c, start = list(p = 1,c=1))
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ x^p+c, start = list(p = 1,c=2))
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ x^p+c, start = list(p = 1,c=4))
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ x^p + c, start = list(p = 1, c = 4))
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ x^p + c, start = list(p = 2, c = 4))
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ x^p + c)
m1 <- nls(y ~ (x^p + c))
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ (x^p + c),start = list(p = 1, c = 2))
x <- c(datos$`Tiempo V1` , datos$`Tiempo V2` , datos$`Tiempo V3`)
y <- c(datos$`Velocidad V1` , datos$`Velocidad V2` , datos$`Velocidad V3`)
datos <- data.frame(x=x,y=y)
View(datos)
View(datos)
estimar_valores_iniciales <- function(datos=datos) {
# Gráfico de dispersión de y vs. x
plot(datos$x, datos$y, main = "Gráfico de dispersión", xlab = "x", ylab = "y")
# Utiliza la función locator() para seleccionar puntos en el gráfico
puntos <- locator(n = 2, type = "p", col = "red")
# Extrae las coordenadas de los puntos seleccionados
x_valores_iniciales <- puntos$x
y_valores_iniciales <- puntos$y
# Calcula los valores iniciales para p y c
p_inicial <- log(y_valores_iniciales[2] - y_valores_iniciales[1]) / log(x_valores_iniciales[2] - x_valores_iniciales[1])
c_inicial <- y_valores_iniciales[1] - x_valores_iniciales[1]^p_inicial
# Devuelve los valores iniciales estimados
return(list(p_inicial = p_inicial, c_inicial = c_inicial))
}
# Uso de la función para estimar valores iniciales
valores_iniciales_estimados <- estimar_valores_iniciales(datos)
print(valores_iniciales_estimados)
View(valores_iniciales_estimados)
install.packages("minpack.lm")
# Cargar la biblioteca minpack.lm
library(minpack.lm)
# Función de modelo
modelo <- function(x, p, c) {
return(x^p + c)
}
# Estimar valores iniciales utilizando nlsLM
ajuste_inicial <- nlsLM(y ~ modelo(x, p, c), start = list(p = 1, c = 1))
# Obtener los valores iniciales estimados
valores_iniciales_estimados <- coef(ajuste_inicial)
print(valores_iniciales_estimados)
# Ajustar el modelo final con los valores iniciales estimados
ajuste_final <- nlsLM(y ~ modelo(x, p, c), start = valores_iniciales_estimados)
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ (x^p + c),start = list(p = -2.334564, c = 12.074168 ))
# summary(m1)
# teta <- coefficients(m1)
# points(xx,(xx^teta),type="l",col="red")
summary(m1)
teta <- coefficients(m1)
teta
teta[0]
teta[,0]
plot(x,y)
points(x,(x^(-2.334684) + 12.074184 ),type="l",col="red")
# Cargar la biblioteca minpack.lm
library(minpack.lm)
# Función de modelo
modelo <- function(x, p, c) {
return(x^p + c)
}
# Estimar valores iniciales utilizando nlsLM
ajuste_inicial <- nlsLM(y ~ modelo(x, p, c), start = list(p = 2, c = 4))
# Obtener los valores iniciales estimados
valores_iniciales_estimados <- coef(ajuste_inicial)
print(valores_iniciales_estimados)
# Ajustar el modelo final con los valores iniciales estimados
ajuste_final <- nlsLM(y ~ modelo(x, p, c), start = valores_iniciales_estimados)
# Cargar la biblioteca minpack.lm
library(minpack.lm)
# Función de modelo
modelo <- function(x, p, c) {
return(x^p + c)
}
# Estimar valores iniciales utilizando nlsLM
ajuste_inicial <- nlsLM(y ~ modelo(x, p, c), start = list(p = 4, c = 4))
# Obtener los valores iniciales estimados
valores_iniciales_estimados <- coef(ajuste_inicial)
print(valores_iniciales_estimados)
# Ajustar el modelo final con los valores iniciales estimados
ajuste_final <- nlsLM(y ~ modelo(x, p, c), start = valores_iniciales_estimados)
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ (x^p + c),start = list(p = 1, c = 1 ),weights = 1/(y^2))
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ ((x-a)^p + c),start = list(a=0.8,p = -1, c = 9 ))
x
legend(x)
length(x)
length(y)
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ I((x-a)^p + c),start = list(a=0.8,p = -1, c = 9 ))
# MODELO AJUSTE DE CURVA y(teta) = X^teta + ei
m1 <- nls(y ~ (x-a)^p + c,start = list(a=0.8,p = -1, c = 9 ))
